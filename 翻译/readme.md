---
title: 基于LSB匹配重访问的边缘自适应图像隐写技术
---
使用`pandoc`得到`.docx`文档

````
pandoc -o h.docx -s -S --bibliography=transref.bib --csl ieee.csl readme.md
````

## 摘要
基于最低有效位（LSB）方法是一种在空间域中流行的隐写算法。然而，我们发现在大多数现存的方法中，对于载体图片的嵌入位置的选择取决于伪随机数生成器，而没有考虑图片内容本身和密文大小的关系。所以，即使数据以非常低的嵌入率隐藏后，载体图片中的光滑/平坦区域也很容易被污染，这会导致在我们的分析和扩展试验中，尤其是含有较多光滑区域的图片中，出现较差的视觉质量和安全表现。在这篇文章中，我们将拓展LSB匹配重访问图像隐写技术并提出一种可以根据密文大小和载体图片中连续两个像素之间的差异选择嵌入位置的边缘自适应模式。对于更低的嵌入率，只有使用更尖锐的边缘区域才能同时维持平滑区。当嵌入率增大时，只需要调整几个参数就可以自适应地释放更多的边缘区域用于数据隐藏。在6000张自然图片上使用三种特定的和四种通用的隐写分析算法得到的实验结果表明，对比典型的基于LSB方法以及它们对应的边缘适应方法，比如基于像素值差异的方法，新模式可以显著增强安全性，同时保证隐秘图像的视觉质量较高。

### 索引词
基于内容的隐写术，基于最低有效位（LSB）的隐写术，像素值差（PVD），安全，隐写分析

## 1. 介绍
隐写术是一种信息隐藏技术，旨在将隐秘数据嵌入数字载体媒体而不引起怀疑，比如数字音频，图像，视频等。另一方面，隐写分析则旨在发现这些伪装媒体中隐藏的秘密消息。如果存在一种能以比随机猜测的概率更高的概率猜出一个给定的媒体是否是载体的隐写分析算法，那么这个隐写系统就被认为是被攻破了。在实践中，两个熟悉，不可探测性和嵌入容量，在设计隐写算法时应该被慎重考虑。通常来说，在载体中的负载嵌入越大，伪装中可探查到的人为迹象越多。在许多应用中，对于隐写来说最重要的需求就是不可探查，这意味着伪装应该在尽可能高嵌入率的同时在视觉和统计意义上与载体相似。这篇文章中，我们考虑数字图片作为载体并研究一种在空间最低有效位（LSB）域自适应的安全数据隐藏模式。

LSB替换是一种著名的隐写方法。在这种嵌入模式中，只有载体的LSB平面依据伪随机数生成器被秘密比密文比特流重写。因此，一些结构性的对称（在隐藏数据时）从不较少偶数像素和增加奇数像素被引入，致使在低嵌入率的情况下，即使使用一些公开算法，比如$\chi ^2$攻击[@westfeld1999attacks]，R/S块分析[@fridrich2001reliable]，样本对分析[@dumitrescu2003detection]，和广义上的结构性隐写分析框架[@ker2005general]，[@ker2007fusion],也很容易探查到隐藏消息的存在。


LSB匹配（LSBM）对于LSB代替做了一些微小的修改。如果秘密位不匹配载体图片的LSB，那么就在对于的像素值上随机加$+1$或者$-1$。统计意义上而已，对于每个改变的像素值增大和减小的概率是相等的，因此由LSB代替引入的明显的对称的人工迹象可以很容易被避免。因此，常见的侦测LSB代替的方法都在侦测LSBM时无效。到现在为止，几种分析算法（如[@harmsen2003steganalysis; @ker2005steganalysis; @huang2007attack; @li2008detecting]）被提出用于分析LSBM机制。在[@harmsen2003steganalysis]中，[-@harmsen2003steganalysis]演示了LSBM作为低通过滤器在图像上的直方图，说明了相比载体，伪装图片的直方图包含少的高频成分。基于这个特性，作者引入了一种使用直方图特征函数（HCF）的质心（COM）的探测器。在[@ker2005steganalysis]中，Ker指出原始的HCF COM方法在灰度图像上效果不佳并引入了两种应用HCF COM方法的途径，称之为利用下采样图像和以邻接直方图代替传统直方图，它们在由达到58的低质量因数压缩JPEG图像而成的灰度图像上非常有效。在近期的工作[@li2008detecting]中，Li等人提出在不同的图像上计算基于刻度的探测器，如刻度HCF COM。实验结果表明新的探测器优于Ker在[@ker2005steganalysis]中的方法，并且达到了50%的可以接受的准确率。在[@huang2007attack]中，Huang等人调研了这些包含图像前两比特的子图中的小量重叠部分的统计特征并提出另一种基于邻接像素值的可替换率的分析方法。实验结果表明这种方法对于未经压缩的灰度图像更有效。除了这些特定的探测器，一些通用的分析算法如[@shi2005image]，[@li2008textural]和[@goljan2006new]也能以相对较高的探测率暴露使用LSBM和/或其他隐写方法的伪装图像。

和LSB替换以及LSBM这些独立处理像素值的方法不同，LSB匹配重访问使用像素对作为嵌入单元，第一个像素的LSB携带了一比特的密文，两个像素值的关系（奇偶组合）[@mielikainen2006lsb]携带了另一比特密文。在这种方式下，就最高嵌入率 而言，像素的更改率可以从0.5下降到0.375比特/像素（bpp），也就是说相比LSB替换和LSBM在相同的负载下对于载体图像的改变更少。这说明了这样一种新模式可以避免LSB替换风格的对称，也因此在我们的试验中它比LSBM略微难以探测一些。

典型的基于LSB的方法，包括LSB替换，LSBM和LSBMR，处理每个给定的像素/像素对时不考虑与像素与它的邻接像素的差异。直到现在，对几种边缘适应机制如[@hempstalk2006hiding; @singh2007hiding; @swanson1996robust; @wu2003steganographic; @zhang2004vulnerability; @yang2008adaptive]进行研究，在[@hempstalk2006hiding]中Hempstalk提出了根据一个像素与它周围的四个像素值的差值替换LSB的机制。尽管这种方法可以在较锐利的边缘嵌入最多的秘密数据并成为了视觉上更不易被察觉的伪装（见图1和表1），但是安全表现太弱。因为此方法在隐藏数据时只修改LSB，很容易被现有的隐写分析算法，比如RS分析（请参见C1小节)探测出来。在[@singh2007hiding]中，Singh等作者提出一种嵌入方法，先在载体的每个$3 \times 3$不重叠的区域上部署Laplacian探测器来探测边缘，再根据一个阈值$\theta$选出更锐利的边缘，在这些边缘上的区域的中心像素进行数据隐藏。如[@singh2007hiding]所述，这种方法的嵌入容量相对较低（$1/9  \approx 11.1\%$）。不仅如此，阈值 $\theta$也需要预先决定所以不能根据图像内容和要嵌入的消息自适应地改变。基于像素值差（PVD）的机制（如[@wu2003steganographic; @zhang2004vulnerability; @yang2008adaptive]）是另一种边缘自适应机制，嵌入像素的数量由一个像素和它的邻接像素的差值决定。差值越大，能被嵌入的秘密比特越多。通常来说，基于PVD的方法可以提供更大的嵌入容量（平均来说超过1bpp）。然而基于我们的扩展实验，我们发现现有的PVD方法未能充分利用边缘信息进行数据隐藏，而且在对抗一些统计分析方面也很弱。

大多数上述的隐写方法的一个共同特征就是像素/像素对的选择主要取决于一个PRNG而忽视了图像内容和密文大小的关系。如此操作，这些方法甚至可以以很低的嵌入率将密文随机地在整个伪装图像上分散。然而，基于我们的分析和扩展实验，我们发现这样的嵌入机制在伪装图片的安全和视觉质量上表现欠佳。假设一个图像由不重叠的小子图（区域）按照一个预先决定的规则组成，不同的区域通常有不同的隐藏消息的容量。与载体图片的选择问题相似[@kharrazi2006cover]，我们应该优先选择那些有良好的隐藏特征的子图，同时不对其他子图作出任何改变。因此，决定如何选择区域是我们提出的机制的关键。一般来说，在较锐利的边缘的区域表现出更复杂的统计特征，并且对于图像内容高度依赖。不仅如此，与平滑区相比，锐利的边缘更难察觉出变化。

在这篇文章中，我们提出一种边缘自适应的机制并且将其应用于基于LSBMR的方法。在上千张图像上使用数种隐写分析算法进行评价得到的实验结果体现了新方法的优越性。

这篇文章余下的部分如下安排。节2分析相关隐写机制的局限并提出一些策略。节3展示在我们的机制中数据嵌入和数据提取的细节。节4给出实验结果和讨论。最后，在节5给出总结评价和未来的工作。

## 2.相关方法和策略的局限分析

在本节，我们首先给出对于典型的基于LSB的方法，包括LSB替换，LSBM, 和LSBMR，以及包括原始PVD机制[@wu2003steganographic]，PVD的优化版本（IPVD)[@zhang2004vulnerability]，自适应边缘的LSB（AE-LSB）[@yang2008adaptive]和隐藏在角落（HBC）[@hempstalk2006hiding]在内的一些自适应机制的简要综述，然后展示一些图像来暴露这些机制的局限。最后我们提出一些策略来克服这些局限。

在LSB替换和LSBM方法中，植入过程非常相似。给定一个秘密比特流用以嵌入，PRNG就会生成一个在载体图片的访问顺序，然后分别处理访问顺序上的每一个比特。对于LSB替换，秘密比特重新了像素的LSB，即第一个比特平面，同时保留更高位的比特平面（2~8）。对于LSBM机制，如果秘密比特不等于给定的像素的LSB，那么这个像素就随机地增加$\pm 1$同时保持改变的像素值在$\left[ {0,255} \right]$范围内。在这样的方法中，用LSB替换和LSBM隐藏数据后，访问顺序中的像素的LSB会和秘密比特流匹配。因此，两种方法的提取过程完全相同，先根据共享秘钥生成相同的访问顺序，然后检查像素值的对等比特就能正确提取隐藏的消息。

LSBMR应用载体图像中的一对像素$\left( {{x_i},{x_{i + 1}}} \right)$对作为嵌入单元。消息嵌入后，伪装图片中修改后的单元$\left( {x{'_i},x{'_{i + 1}}} \right)$满足$$LSB\left( {x{'_i}} \right) = {m_i}, \quad LSB\left( {\left\lfloor {\frac{{x{'_i}}}{2}} \right\rfloor  + x{'_{i + 1}}} \right) = {m_{i + 1}}$$其中函数$LSB\left( x \right)$为像素值$x$的LSB,$m_i$和$m_{i+1}$是需要嵌入的两个秘密比特。

通过邻接像素的关系（奇偶组合），对比同嵌入率的LSB替换和LSBM，LSBMR的像素改变率降低。类似地，数据提取时，首先使用共享秘钥用PRNG生成一个访问顺序。然后对于访问顺序的每个嵌入单元可以提取两比特。第一个秘密比特的值就是第一个像素值的LSB，进而第二个比特可以通过上述方法计算两个像素的关系。

我们人类的视觉对于光滑区的微小改动很敏感，却可以容忍边缘区域的剧烈变化。几种基于PVD的方法如[@wu2003steganographic; @zhang2004vulnerability; @yang2008adaptive]提议增加嵌入容量而不在伪装图片中引入明显的人工痕迹。基于PVD方法的基本思想是首先把载体图片划分为多个不重叠的含有两个连续像素的单元，然后处理由PRNG生成的随机顺序上的嵌入单元。两个像素间的差值越大，可植入该单元的秘密比特越多。在一定程度上，现有的基于PVD的方法是边缘自适应的，因为在那些拥挤的边缘区域被植入的秘密比特更多。然而，与LSBM和LSBMR相似的是，像素对的选择主要依赖于PRNG，也就是说改变的像素仍然会分布于整个伪装图片如图1所示。我们可以看到许多平滑区在数据隐藏后也不可避免地发生了改变，即使两个连续像素间的差值是零（意味着子图在平坦区上），同时许多锐利的边缘区域却未充分利用。

大多数现有的隐写分析算法通常假设自然载体的LSB不够重要和随机，因此那些那些用于数据隐藏的像素/像素对是使用PRNG自有地选择出来的。但是，这样的假设不是一直正确，尤其是对于包含很多平滑区的图像。图2显示了这些图例的LSB平面。我们可以观察到LSB在一定程度上可以反映图像的纹理信息。在扩展实验中，我们发现未经压缩的自然图像通常包含一些平坦区（可能只有$5 \times 5$大小而且很难注意到），LSB在那些区域的值相同（$1$或$0$）。因此，如果我们将秘密比特嵌入这些区域，伪装图像的LSB会变得越来越随机，可能如图3所示产生载体（包含平坦区域/纹理信息）和伪装图像（看上去像噪声分布）的LSB之间视觉和统计上的差异。

与平滑区相比，位于边缘区域像素的LSB通常表现出更随机的特征，它们在统计上与秘密比特的分布（假设是一个$0/1$均匀分布）更相似。所以，我们希望数据隐藏后边缘区域留下了更少的可探测的和视觉上的人工痕迹。不仅如此，边缘信息（比如位置和统计矩）高度依赖于图像内容，使得探测更为困难。这就是为什么我们提出的机制首先尽可能地将秘密比特嵌入边缘区域而不改变平滑区域。如图1所示，我们发现HBC方法[@hempstalk2006hiding]有这种属性。但是HBC方法只修改LSB二保持最关键的比特位不变，所以它可以被视为LSB替换的一种边适应的情况，LSB替换式的对称在他们的方法中仍会存在。我们将在IV-C1小节给出一些实验证据来暴露HBC方法的局限。

请注意我们在这篇文章中没有评价JPEG图片的安全性。原因是JPEG图像中所有不重叠的$8 \times 8$区域都经过了有损耗的JPEG压缩后按照一定规律重排。如果在JPEG解压图像上使用空域隐写分析方法必然会出现JPEG不兼容[@fridrich2001steganalysis]，也就是附加秘密数据将毁坏之前使用量化表的JPEG压缩引入的特有的指纹。我们甚至可以从JPEG伪装图片中短到一比特的数据中探测到可能的隐藏消息。

## 3.建议机制
我们的建议机制的流程图如图4所示。在数据嵌入阶段，先初始化一些用于后续数据处理和区域选择的参数，然后估测这些选择区域的容量。如果区域大到足够隐藏给定的密文$M$,那么就在这些选出的区域上进行数据隐藏。最后，我们做一些后处理得当伪装图片。否则，我们的方法需要修改这些参数，然后重复区域选择和容量估测直至$M$能完全被嵌入。

请注意对于不同的图片内容和密文$M$，这些参数也可能不同。我们需要把它们作为辅助信息来保证数据提取的有效性，在实践中，可以将这样的辅助信息（我们的工作中是7比特）嵌入图像中预先选出的区域。

在数据提取中，这样的机制首先从伪装图片中提取这些辅助信息。基于这些辅助信息，我们可以做一些预处理并辨别出有隐藏数据的区域。最后，根据对应的提取算法可以得到密文$M$。

在这篇文章中，我们对空间LSB域使用这样的一种区域自适应机制。我们使用两个邻接像素的绝对差作为区域选择的准则，并使用LSBMR作为隐藏算法。数据嵌入和提取算法的细节如下。

### 数据嵌入

- 第一步：先将大小为$m \times n$的载体图片划分为$Bz \times Bz$像素的不重叠区域块。 对于这些小区域块，我们根据秘钥$key_1$以范围为$\left\{ {0,90,180,270} \right\}$的角度随机旋转它，得到的结果图像被行式扫描重排为一个行向量$V$。接下来这个向量被划分成包含两个连续像素$\left( {{x_i},{x_{i + 1}}} \right)$的不重叠的嵌入单元，其中$i = 1,3, \ldots ,mn - 1$，假设$n$是一个奇数。
随机旋转有两个益处。首先，它可以防止探测器在没有旋转秘钥$key_1$的前提下获得正确的植入单元，因此安全性得到提升。除此之外，载体图像中水平和垂直的边缘（像素对）都可以用于隐藏数据。
- 第二步：根据LSBMR机制，每个嵌入单元可以嵌入2比特密文。因此，对于一个给定的密文$M$，区域选择的阈值$T$可以以如下的方式决定。令$EU\left( t \right)$表示绝对差大于参数$t$的像素对的集合$$EU\left( t \right) = \left\{ {\left( {{x_i},{x_{i + 1}}} \right)|\left| {{x_i} - {x_{i + 1}}} \right| \ge t,\forall \left( {{x_i},{x_{i + 1}}} \right) \in V} \right\}.$$然后我们这样计算阈值$T$$$T = \arg \mathop {\max }\limits_t \left\{ {2 \times \left| {EU\left( t \right)} \right| \ge \left| M \right|} \right\}$$其中$t \in \left\{ {0,1 \ldots ,31} \right\}$，$\left| M \right|$是密文$M$的大小，$\left|{EU\left( t \right)} \right|$是集合$EU\left( t \right)$中元素的总数。
注意当$T=0$时，建议方法就成为了常规的LSBMR机制，意味着我们的方法达到了LSBMR相同的负载容量（除了7比特）
- 第三步：在集合上进行数据隐藏$$EU\left( T \right) = \left\{ {\left( {{x_i},{x_{i + 1}}} \right)|\left| {{x_i} - {x_{i + 1}}} \right| \ge T,\forall \left( {{x_i},{x_{i + 1}}} \right) \in V} \right\}.$$我们用秘钥$key_2$决定的伪随机顺序处理上述的嵌入单元。对于每一个单元$\left( {{x_i},{x_{i + 1}}} \right)$，我们根据下面的四种情况进行数据隐藏：$$
\begin{aligned}
Case\# 1:& LSB\left( {{x_i}} \right) = {m_i}\& f\left( {{x_i},{x_{i + 1}}} \right) = {m_{i + 1}}\\
& \left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i},{x_{i + 1}}} \right);\\
Case\# 2:&LSB\left( {{x_i}} \right) = {m_i}\& f\left( {{x_i},{x_{i + 1}}} \right) \ne {m_{i + 1}}\\
& \left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i},{x_{i + 1}}}+r \right);\\
Case\# 3:& LSB\left( {{x_i}} \right) \ne {m_i}\& f\left( {{x_i}-1,{x_{i + 1}}} \right) = {m_{i + 1}}\\
& \left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i}-1,{x_{i + 1}}} \right);\\
Case\# 4:& LSB\left( {{x_i}} \right) \ne {m_i}\& f\left( {{x_i}-1,{x_{i + 1}}} \right) \ne {m_{i + 1}}\\
& \left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i}+1,{x_{i + 1}}} \right);\\
\end{aligned}$$
其中$m_i$和$m_{i+1}$表示被嵌入的两个秘密比特，函数$f$定义为$f\left( {a,b} \right) = LSB\left( {\left\lfloor {a/2} \right\rfloor  + b} \right)$，$r$是$\left\{ { - 1, + 1} \right\}$中的一个随机值，$\left( {x{'_i},x{'_{i + 1}}} \right)$表示数据隐藏后的像素对。
上述修改后，$x{'_i}$和$x{'_{i + 1}}$可能超出了$\left[ {0,255} \right]$，或者新的差$\left( {x'{'_i},x'{'_{i + 1}}} \right) = \arg {\min _{\left( {{e_1},{e_2}} \right)}}\left\{ {\left| {{e_1} - {x_i}} \right| + \left| {{e_2} - {x_{i + 1}}} \right|\left| {{e_1} = x{'_i} + 4{k_1},{e_2} = x{'_{i+1}} + 2{k_2},\left| {{e_1} - {e_2}} \right| \ge T,0 \le {e_1},{e_2} \le 255,0 \le T \le 31,{k_1},{k_2} \in Z} \right.} \right\}$重新调整$\left( {x'{'_i},x'{'_{i + 1}}} \right)$，最后，我们得到$$LSB\left( {x'{'_i}} \right) = {m_i},\quad f\left( {x'{'_i},x'{'_{i + 1}}} \right) = {m_{i + 1}}$$其中$0 \le x'{'_i},x'{'_{i + 1}} \le 255$,$\left| {x'{'_i} - x'{'_{i + 1}}} \right| \ge T$。解的存在性证明请参见附录。
- 第四步：数据隐藏后，结果图像被分成不重叠的$Bz \times Bz$区域块，然后将区域块按照根据$key_1$生成的随机的角度旋转。这个过程与第一步非常相似，除了随机角度是相反的。接下来我们在没有用于隐藏数据的一个预先设置的区域嵌入两个参数$\left( {T,Bz} \right)$

注意我们的方法有两个参数。第一个是数据预处理时用于区域划分的区域块大小$Bz$，另一个是嵌入区域选择使用的阈值$T$。在这篇文章中，$Bz$是从集合$\left\{ {1,4,8,12} \right\}$中随机选出。$T$属于$\left\{ {0,1 \ldots ,31} \right\}$并由图像内容和密文$M$（请参加第二步）。总之，每个图像只需要7（$7 = {\log _2}\left( 4 \right) + {\log _2}\left( {32} \right)$）比特的辅助信息。

这里给出一个例子。假设我们处理嵌入单元$\left( {{x_i},{x_{i + 1}}} \right)=\left(62,81\right)$，$m_i=1$，$m_{i+1}=0$，$T=19$。易得$\left| {{x_{i + 1}} - {x_i}} \right| = 19 \ge T$和$$\begin{align}
LSB\left( {62} \right) & = 0 \ne {m_i},\\
LSB\left( {\left\lfloor {\frac{{\left( {62 - 1} \right)}}{2}} \right\rfloor  + 81} \right) & = 1 \ne {m_{i + 1}}
\end{align}$$因此，我们调用Case\#4得到$$\left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i} + 1,{x_{i + 1}}} \right) = \left( {63,81} \right)$$新的差变成$d' = \left| {81 - 63} \right| = 18 < T$，我们根据公式重新调整它们最后得到$k_1=0,k_2=1$,$$\begin{align}
x'{'_i} &= x{'_i} + 4{k_1} = 63 + 4 \times 0 = 63\\
x'{'_{i + 1}} &= x{'_{i + 1}} + 2{k_2} = 81 + 2 \times 1 = 83
\end{align}$$在这里，我们有$d'' = \left| {83 - 63} \right| = 20 \ge T$和$$LSB\left( {63} \right) = {m_i},\quad LSB\left( {\left\lfloor {\left( {\frac{{63}}{2}} \right)} \right\rfloor  + 83} \right) = {m_{i + 1}}$$

###数据提取
为了提取数据，我们先从伪装图片提取辅助信息，即区域分块大小$Bz$和阈值$T$。然后我们做的工作和数据嵌入的第一步完全相同。伪装图像被划分为$Bz \times Bz$的分块区域，分块根据秘钥$key_1$生成的随机角度旋转。结果图像重排为一个行向量$V'$，最后，我们通过把$V'$划分为不重叠的两个连续的像素得到嵌入单元。

我们根据由秘钥$key_2$生成的伪随机顺序遍历绝对差大于等于阈值$T$的嵌入单元，直至所有的隐藏比特都被完全提取。对于每个合格的嵌入单元，也就是满足$\left| {x{'_{i + 1}} - x{'_i}} \right| \ge T$的$\left( {x{'_i},x{'_{i + 1}}} \right)$，我们这样提取两个秘密比特$m_i,m_{i+1}$:$${m_i} = LSB\left( {x'{'_i}} \right),\quad {m_{i + 1}} = LSB\left( {\left\lfloor {\frac{{x{'_i}}}{2}} \right\rfloor  + x{'_{i + 1}}} \right)$$，例如，我们处理单元$\left( {x{'_i},x{'_{i + 1}}} \right)=\left(63,83\right)$，$T=19$，我们最终这样得到秘密比特$${m_i} = LSB\left( {63} \right) = 1,\qquad {m_{i + 1}} = LSB\left( {\left\lfloor {\frac{{63}}{2}} \right\rfloor  + 83} \right) = 0$$

## 实验结果和分析
在本节，我们将展现一些实验结果以表明我们提出的方法相比于在第二节中现有相关方法的有效性。我们使用了三个图像数据集用于算法评估，UCID[@schaefer2003ucid]包含1338个未压缩的大小为$384\times512$或$512\times384$彩色图像，NJIT数据集包含3680个使用不同相机拍摄的未压缩的大小为$512\times 768$或$768\times 512$彩色图像，以及我们的数据集SYSU包含982个大小为$640 \times 489$TIFF彩色图像。总之，有6000个原始的未压缩的图片包含（但不限于）风景，人物，植物，动物和建筑。所有图像在我们的实验中都转换成了灰度图像。

###嵌入容量和图片质量分析
我们的隐写方法的一个属性就是可以通过调整阈值$T$根据图片内容先选择较锐利的边缘区域来隐藏数据。如图5所示，要嵌入的秘密比特越多，阈值$T$变得越小，也就是更多载体图像中更低渐变的嵌入单元被释放了（请参加数据嵌入第三步中$EU\left( T \right)$的定义）。当$T$为$0$时，载体中所有的嵌入单元都可用。在这种情况下，我们的方法达到最大的嵌入容量100\%（对于文中所有方法100\%意味着1bpp），所以，我们提出的方法的嵌入容量除了7个额外的比特以外与LSBM和LSBMR几乎相同。

从图5可知，当嵌入率低时，大多数秘密比特都隐藏在边缘区域，比如，例子中低于30\%，这时这些光滑区比如左上角的天空保持不变。因此，我们的伪装的主观质量得到了基于人类视觉系统（HVS）特性的提升。

表1显示了嵌入率不同的七种隐写方法在6000张图像上的平均PSNR，加权PSNR(wPSNR是一种Checkman版本1.2[@pereira2001second]采用的更好的图像视觉度量，它考虑了HVS特征并用$$wPSNR = 10{\log _{10}}\frac{{\max {{\left( x \right)}^2}}}{{{{\left\| {NVF\left( {x' - x} \right)} \right\|}^2}}}$$优化传统的PSNR,其中$x$是载体图像，$x'$是伪装图像，$NVF$为噪声可见函数[@voloshynovskiy1999stochastic]）和平均修改率。\_

对于平均PSNR，可以看到LSBMR的表现最佳因为它使用了$\pm 1$嵌入机制，而且它的修改率低于除了AE-LES方法以外的其他方法。请注意PSNR的值独立于被修改像素的位置，因此我们的方法评价PSNR将略微低于LSBMR因为我们的方法需要重新调整一些嵌入单元保证正确的数据提取（更多细节见附录）。

对于评价wPSNR，HBC和我们的方法的表现非常相似并且通常优于其他方法，原因是使用这两种方法隐藏数据后，修改的像素总是位于载体上更锐利的边缘区域而光滑区保持不变（见图1），根据[@pereira2001second]的HVF，锐利的边缘地区的改变的权重小于光滑区，这意味着wPSNR的值应该大于那些用随机嵌入机制伪装的图像。

对于平均修改率，AE-LSB方法总是最低的。原因是根据AE-LSB嵌入的步骤，每个单个的像素的负载容量在所有方法中是最大的，也就是说对于相同的嵌入容易需要修改的像素更少。注意LSBM和HBC的平均修改率相同，都等于嵌入率的一半，或者LSBMR修改率的$4/3$。

综上所述，包括PSNR和wPSNR的我们的伪装的客观之类几乎是七种方法中最好的（对比下划线和括号里的数据）

## 视觉攻击
尽管我们的方法通过改变那些边缘区域上的像素来嵌入密文比特，但是在我们的扩展试验中不会在伪装图像的LSB平面留下明显的人工痕迹。图6是载体图片的LSB平面和应用我们的机制嵌入率为30\%和50\%的伪装图片的LSB平面，可见没有图5中的可见痕迹，大部分光滑区域如左上角的天空也很好的保持了原样，然而对于LSBM，LSBMR和一些随机嵌入机制的基于PVD的方法，光滑区不可避免地被污染从而变得更加随机。图7是载体的LSB平面和相同嵌入率50\%下分别使用七种隐写方法的伪装图像的LSB平面，可知使用LSBM，LSBNR，PVD和IPVD方法（尤其是有着高修改率的LSBM）的伪装图像的LSB平面比起其他方法的看上去更随机。如图3所示，放大后更容易观察到人工痕迹。注意HBC也能保留光滑区，而AE-LSB由于表1所示的低修改率，污染的光滑区更少。
