---
title: 基于LSB匹配重访问的边缘自适应图像隐写技术
---
使用`pandoc`得到`.docx`文档

````
pandoc -o h.docx -s -S --bibliography=transref.bib --csl ieee.csl readme.md
````

## 摘要
基于最低有效位（LSB）方法是一种在空间域中流行的隐写算法。然而，我们发现在大多数现存的方法中，对于载体图片的嵌入位置的选择取决于伪随机数生成器，而没有考虑图片内容本身和密文大小的关系。所以，即使数据以非常低的嵌入率隐藏后，载体图片中的光滑/平坦区域也很容易被污染，这会导致在我们的分析和扩展试验中，尤其是含有较多光滑区域的图片中，出现较差的视觉质量和安全表现。在这篇文章中，我们将拓展LSB匹配重访问图像隐写技术并提出一种可以根据密文大小和载体图片中连续两个像素之间的差异选择嵌入位置的边缘自适应模式。对于更低的嵌入率，只有使用更尖锐的边缘区域才能同时维持平滑区。当嵌入率增大时，只需要调整几个参数就可以自适应地释放更多的边缘区域用于数据隐藏。在6000张自然图片上使用三种特定的和四种通用的隐写分析算法得到的实验结果表明，对比典型的基于LSB方法以及它们对应的边缘适应方法，比如基于像素值差异的方法，新模式可以显著增强安全性，同时保证隐秘图像的视觉质量较高。

### 索引词
基于内容的隐写术，基于最低有效位（LSB）的隐写术，像素值差（PVD），安全，隐写分析

## 介绍
隐写术是一种信息隐藏技术，旨在将隐秘数据嵌入数字载体媒体而不引起怀疑，比如数字音频，图像，视频等。另一方面，隐写分析则旨在发现这些伪装媒体中隐藏的秘密消息。如果存在一种能以比随机猜测的概率更高的概率猜出一个给定的媒体是否是载体的隐写分析算法，那么这个隐写系统就被认为是被攻破了。在实践中，两个熟悉，不可探测性和嵌入容量，在设计隐写算法时应该被慎重考虑。通常来说，在载体中的负载嵌入越大，伪装中可探查到的人为迹象越多。在许多应用中，对于隐写来说最重要的需求就是不可探查，这意味着伪装应该在尽可能高嵌入率的同时在视觉和统计意义上与载体相似。这篇文章中，我们考虑数字图片作为载体并研究一种在空间最低有效位（LSB）域自适应的安全数据隐藏模式。

LSB替换是一种著名的隐写方法。在这种嵌入模式中，只有载体的LSB平面依据伪随机数生成器被秘密比密文比特流重写。因此，一些结构性的对称（在隐藏数据时）从不较少偶数像素和增加奇数像素被引入，致使在低嵌入率的情况下，即使使用一些公开算法，比如$\chi ^2$攻击[@westfeld1999attacks]，R/S块分析[@fridrich2001reliable]，样本对分析[@dumitrescu2003detection]，和广义上的结构性隐写分析框架[@ker2005general]，[@ker2007fusion],也很容易探查到隐藏消息的存在。


LSB匹配（LSBM）对于LSB代替做了一些微小的修改。如果秘密位不匹配载体图片的LSB，那么就在对于的像素值上随机加$+1$或者$-1$。统计意义上而已，对于每个改变的像素值增大和减小的概率是相等的，因此由LSB代替引入的明显的对称的人工迹象可以很容易被避免。因此，常见的侦测LSB代替的方法都在侦测LSBM时无效。到现在为止，几种分析算法（如[@harmsen2003steganalysis; @ker2005steganalysis; @huang2007attack; @li2008detecting]）被提出用于分析LSBM机制。在[@harmsen2003steganalysis]中，[-@harmsen2003steganalysis]演示了LSBM作为低通过滤器在图像上的直方图，说明了相比载体，伪装图片的直方图包含少的高频成分。基于这个特性，作者引入了一种使用直方图特征函数（HCF）的质心（COM）的探测器。在[@ker2005steganalysis]中，Ker指出原始的HCF COM方法在灰度图像上效果不佳并引入了两种应用HCF COM方法的途径，称之为利用下采样图像和以邻接直方图代替传统直方图，它们在由达到58的低质量因数压缩JPEG图像而成的灰度图像上非常有效。在近期的工作[@li2008detecting]中，Li等人提出在不同的图像上计算基于刻度的探测器，如刻度HCF COM。实验结果表明新的探测器优于Ker在[@ker2005steganalysis]中的方法，并且达到了50%的可以接受的准确率。在[@huang2007attack]中，Huang等人调研了这些包含图像前两比特的子图中的小量重叠部分的统计特征并提出另一种基于邻接像素值的可替换率的分析方法。实验结果表明这种方法对于未经压缩的灰度图像更有效。除了这些特定的探测器，一些通用的分析算法如[@shi2005image]，[@li2008textural]和[@goljan2006new]也能以相对较高的探测率暴露使用LSBM和/或其他隐写方法的伪装图像。

和LSB替换以及LSBM这些独立处理像素值的方法不同，LSB匹配重访问使用像素对作为嵌入单元，第一个像素的LSB携带了一比特的密文，两个像素值的关系（奇偶组合）[@mielikainen2006lsb]携带了另一比特密文。在这种方式下，就最高嵌入率 而言，像素的更改率可以从0.5下降到0.375比特/像素（bpp），也就是说相比LSB替换和LSBM在相同的负载下对于载体图像的改变更少。这说明了这样一种新模式可以避免LSB替换风格的对称，也因此在我们的试验中它比LSBM略微难以探测一些。

典型的基于LSB的方法，包括LSB替换，LSBM和LSBMR，处理每个给定的像素/像素对时不考虑与像素与它的邻接像素的差异。直到现在，对几种边缘适应机制如[@hempstalk2006hiding; @singh2007hiding; @swanson1996robust; @wu2003steganographic; @zhang2004vulnerability; @yang2008adaptive]进行研究，在[@hempstalk2006hiding]中Hempstalk提出了根据一个像素与它周围的四个像素值的差值替换LSB的机制。尽管这种方法可以在较锐利的边缘嵌入最多的秘密数据并成为了视觉上更不易被察觉的伪装（见图1和表1），但是安全表现太弱。因为此方法在隐藏数据时只修改LSB，很容易被现有的隐写分析算法，比如RS分析（请参见C1小节)探测出来。在[@singh2007hiding]中，Singh等作者提出一种嵌入方法，先在载体的每个$3 \times 3$不重叠的区域上部署Laplacian探测器来探测边缘，再根据一个阈值$\theta$选出更锐利的边缘，在这些边缘上的区域的中心像素进行数据隐藏。如[@singh2007hiding]所述，这种方法的嵌入容量相对较低（$1/9  \approx 11.1\%$）。不仅如此，阈值 $\theta$也需要预先决定所以不能根据图像内容和要嵌入的消息自适应地改变。基于像素值差（PVD）的机制（如[@wu2003steganographic; @zhang2004vulnerability; @yang2008adaptive]）是另一种边缘自适应机制，嵌入像素的数量由一个像素和它的邻接像素的差值决定。差值越大，能被嵌入的秘密比特越多。通常来说，基于PVD的方法可以提供更大的嵌入容量（平均来说超过1bpp）。然而基于我们的扩展实验，我们发现现有的PVD方法未能充分利用边缘信息进行数据隐藏，而且在对抗一些统计分析方面也很弱。

大多数上述的隐写方法的一个共同特征就是像素/像素对的选择主要取决于一个PRNG而忽视了图像内容和密文大小的关系。如此操作，这些方法甚至可以以很低的嵌入率将密文随机地在整个伪装图像上分散。然而，基于我们的分析和扩展实验，我们发现这样的嵌入机制在伪装图片的安全和视觉质量上表现欠佳。假设一个图像由不重叠的小子图（区域）按照一个预先决定的规则组成，不同的区域通常有不同的隐藏消息的容量。与载体图片的选择问题相似[@kharrazi2006cover]，我们应该优先选择那些有良好的隐藏特征的子图，同时不对其他子图作出任何改变。因此，决定如何选择区域是我们提出的机制的关键。一般来说，在较锐利的边缘的区域表现出更复杂的统计特征，并且对于图像内容高度依赖。不仅如此，与平滑区相比，锐利的边缘更难察觉出变化。

在这篇文章中，我们提出一种边缘自适应的机制并且将其应用于基于LSBMR的方法。在上千张图像上使用数种隐写分析算法进行评价得到的实验结果体现了新方法的优越性。

这篇文章余下的部分如下安排。节\ref{limit}分析相关隐写机制的局限并提出一些策略。节3展示在我们的机制中数据嵌入和数据提取的细节。节4给出实验结果和讨论。最后，在节5给出总结评价和未来的工作。

## \label{limit}相关方法和策略的局限分析

在本节，我们首先给出对于典型的基于LSB的方法，包括LSB替换，LSBM, 和LSBMR，以及包括原始PVD机制[@wu2003steganographic]，PVD的优化版本（IPVD)[@zhang2004vulnerability]，自适应边缘的LSB（AE-LSB）[@yang2008adaptive]和隐藏在角落（HBC）[@hempstalk2006hiding]在内的一些自适应机制的简要综述，然后展示一些图像来暴露这些机制的局限。最后我们提出一些策略来克服这些局限。

在LSB替换和LSBM方法中，植入过程非常相似。给定一个秘密比特流用以嵌入，PRNG就会生成一个在载体图片的访问顺序，然后分别处理访问顺序上的每一个比特。对于LSB替换，秘密比特重新了像素的LSB，即第一个比特平面，同时保留更高位的比特平面（2~8）。对于LSBM机制，如果秘密比特不等于给定的像素的LSB，那么这个像素就随机地增加$\pm 1$同时保持改变的像素值在$\left[ {0,255} \right]$范围内。在这样的方法中，用LSB替换和LSBM隐藏数据后，访问顺序中的像素的LSB会和秘密比特流匹配。因此，两种方法的提取过程完全相同，先根据共享秘钥生成相同的访问顺序，然后检查像素值的对等比特就能正确提取隐藏的消息。

LSBMR应用载体图像中的一对像素$\left( {{x_i},{x_{i + 1}}} \right)$对作为嵌入单元。消息嵌入后，伪装图片中修改后的单元$\left( {x{'_i},x{'_{i + 1}}} \right)$满足$$LSB\left( {x{'_i}} \right) = {m_i}, \quad LSB\left( {\left\lfloor {\frac{{x{'_i}}}{2}} \right\rfloor  + x{'_{i + 1}}} \right) = {m_{i + 1}}$$其中函数$LSB\left( x \right)$为像素值$x$的LSB,$m_i$和$m_{i+1}$是需要嵌入的两个秘密比特。

通过邻接像素的关系（奇偶组合），对比同嵌入率的LSB替换和LSBM，LSBMR的像素改变率降低。类似地，数据提取时，首先使用共享秘钥用PRNG生成一个访问顺序。然后对于访问顺序的每个嵌入单元可以提取两比特。第一个秘密比特的值就是第一个像素值的LSB，进而第二个比特可以通过上述方法计算两个像素的关系。

我们人类的视觉对于光滑区的微小改动很敏感，却可以容忍边缘区域的剧烈变化。几种基于PVD的方法如[@wu2003steganographic; @zhang2004vulnerability; @yang2008adaptive]提议增加嵌入容量而不在伪装图片中引入明显的人工痕迹。基于PVD方法的基本思想是首先把载体图片划分为多个不重叠的含有两个连续像素的单元，然后处理由PRNG生成的随机顺序上的嵌入单元。两个像素间的差值越大，可植入该单元的秘密比特越多。在一定程度上，现有的基于PVD的方法是边缘自适应的，因为在那些拥挤的边缘区域被植入的秘密比特更多。然而，与LSBM和LSBMR相似的是，像素对的选择主要依赖于PRNG，也就是说改变的像素仍然会分布于整个伪装图片如图1所示。我们可以看到许多平滑区在数据隐藏后也不可避免地发生了改变，即使两个连续像素间的差值是零（意味着子图在平坦区上），同时许多锐利的边缘区域却未充分利用。

大多数现有的隐写分析算法通常假设自然载体的LSB不够重要和随机，因此那些那些用于数据隐藏的像素/像素对是使用PRNG自有地选择出来的。但是，这样的假设不是一直正确，尤其是对于包含很多平滑区的图像。图2显示了这些图例的LSB平面。我们可以观察到LSB在一定程度上可以反映图像的纹理信息。在扩展实验中，我们发现未经压缩的自然图像通常包含一些平坦区（可能只有$5 \times 5$大小而且很难注意到），LSB在那些区域的值相同（$1$或$0$）。因此，如果我们将秘密比特嵌入这些区域，伪装图像的LSB会变得越来越随机，可能如图3所示产生载体（包含平坦区域/纹理信息）和伪装图像（看上去像噪声分布）的LSB之间视觉和统计上的差异。

与平滑区相比，位于边缘区域像素的LSB通常表现出更随机的特征，它们在统计上与秘密比特的分布（假设是一个$0/1$均匀分布）更相似。所以，我们希望数据隐藏后边缘区域留下了更少的可探测的和视觉上的人工痕迹。不仅如此，边缘信息（比如位置和统计矩）高度依赖于图像内容，使得探测更为困难。这就是为什么我们提出的机制首先尽可能地将秘密比特嵌入边缘区域而不改变平滑区域。如图1所示，我们发现HBC方法[@hempstalk2006hiding]有这种属性。但是HBC方法只修改LSB二保持最关键的比特位不变，所以它可以被视为LSB替换的一种边适应的情况，LSB替换式的对称在他们的方法中仍会存在。我们将在IV-C1小节给出一些实验证据来暴露HBC方法的局限。

请注意我们在这篇文章中没有评价JPEG图片的安全性。原因是JPEG图像中所有不重叠的$8 \times 8$区域都经过了有损耗的JPEG压缩后按照一定规律重排。如果在JPEG解压图像上使用空域隐写分析方法必然会出现JPEG不兼容[@fridrich2001steganalysis]，也就是附加秘密数据将毁坏之前使用量化表的JPEG压缩引入的特有的指纹。我们甚至可以从JPEG伪装图片中短到一比特的数据中探测到可能的隐藏消息。

## 3.建议机制\label{sec::prop}
我们的建议机制的流程图如图4所示。在数据嵌入阶段，先初始化一些用于后续数据处理和区域选择的参数，然后估测这些选择区域的容量。如果区域大到足够隐藏给定的密文$M$,那么就在这些选出的区域上进行数据隐藏。最后，我们做一些后处理得当伪装图片。否则，我们的方法需要修改这些参数，然后重复区域选择和容量估测直至$M$能完全被嵌入。

请注意对于不同的图片内容和密文$M$，这些参数也可能不同。我们需要把它们作为辅助信息来保证数据提取的有效性，在实践中，可以将这样的辅助信息（我们的工作中是7比特）嵌入图像中预先选出的区域。

在数据提取中，这样的机制首先从伪装图片中提取这些辅助信息。基于这些辅助信息，我们可以做一些预处理并辨别出有隐藏数据的区域。最后，根据对应的提取算法可以得到密文$M$。

在这篇文章中，我们对空间LSB域使用这样的一种区域自适应机制。我们使用两个邻接像素的绝对差作为区域选择的准则，并使用LSBMR作为隐藏算法。数据嵌入和提取算法的细节如下。

### 数据嵌入\label{subsec::em}

- 第一步：先将大小为$m \times n$的载体图片划分为$Bz \times Bz$像素的不重叠区域块。 对于这些小区域块，我们根据秘钥$key_1$以范围为$\left\{ {0,90,180,270} \right\}$的角度随机旋转它，得到的结果图像被行式扫描重排为一个行向量$V$。接下来这个向量被划分成包含两个连续像素$\left( {{x_i},{x_{i + 1}}} \right)$的不重叠的嵌入单元，其中$i = 1,3, \ldots ,mn - 1$，假设$n$是一个奇数。
随机旋转有两个益处。首先，它可以防止探测器在没有旋转秘钥$key_1$的前提下获得正确的植入单元，因此安全性得到提升。除此之外，载体图像中水平和垂直的边缘（像素对）都可以用于隐藏数据。
- 第二步：根据LSBMR机制，每个嵌入单元可以嵌入2比特密文。因此，对于一个给定的密文$M$，区域选择的阈值$T$可以以如下的方式决定。令$EU\left( t \right)$表示绝对差大于参数$t$的像素对的集合$$EU\left( t \right) = \left\{ {\left( {{x_i},{x_{i + 1}}} \right)|\left| {{x_i} - {x_{i + 1}}} \right| \ge t,\forall \left( {{x_i},{x_{i + 1}}} \right) \in V} \right\}.$$然后我们这样计算阈值$T$$$T = \arg \mathop {\max }\limits_t \left\{ {2 \times \left| {EU\left( t \right)} \right| \ge \left| M \right|} \right\}$$其中$t \in \left\{ {0,1 \ldots ,31} \right\}$，$\left| M \right|$是密文$M$的大小，$\left|{EU\left( t \right)} \right|$是集合$EU\left( t \right)$中元素的总数。
注意当$T=0$时，建议方法就成为了常规的LSBMR机制，意味着我们的方法达到了LSBMR相同的负载容量（除了7比特）
- 第三步：在集合上进行数据隐藏$$EU\left( T \right) = \left\{ {\left( {{x_i},{x_{i + 1}}} \right)|\left| {{x_i} - {x_{i + 1}}} \right| \ge T,\forall \left( {{x_i},{x_{i + 1}}} \right) \in V} \right\}.$$我们用秘钥$key_2$决定的伪随机顺序处理上述的嵌入单元。对于每一个单元$\left( {{x_i},{x_{i + 1}}} \right)$，我们根据下面的四种情况进行数据隐藏：$$
\begin{aligned}
Case\# 1:& LSB\left( {{x_i}} \right) = {m_i}\& f\left( {{x_i},{x_{i + 1}}} \right) = {m_{i + 1}}\\
& \left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i},{x_{i + 1}}} \right);\\
Case\# 2:&LSB\left( {{x_i}} \right) = {m_i}\& f\left( {{x_i},{x_{i + 1}}} \right) \ne {m_{i + 1}}\\
& \left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i},{x_{i + 1}}}+r \right);\\
Case\# 3:& LSB\left( {{x_i}} \right) \ne {m_i}\& f\left( {{x_i}-1,{x_{i + 1}}} \right) = {m_{i + 1}}\\
& \left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i}-1,{x_{i + 1}}} \right);\\
Case\# 4:& LSB\left( {{x_i}} \right) \ne {m_i}\& f\left( {{x_i}-1,{x_{i + 1}}} \right) \ne {m_{i + 1}}\\
& \left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i}+1,{x_{i + 1}}} \right);\\
\end{aligned}$$
其中$m_i$和$m_{i+1}$表示被嵌入的两个秘密比特，函数$f$定义为$f\left( {a,b} \right) = LSB\left( {\left\lfloor {a/2} \right\rfloor  + b} \right)$，$r$是$\left\{ { - 1, + 1} \right\}$中的一个随机值，$\left( {x{'_i},x{'_{i + 1}}} \right)$表示数据隐藏后的像素对。
上述修改后，$x{'_i}$和$x{'_{i + 1}}$可能超出了$\left[ {0,255} \right]$，或者新的差$\left( {x'{'_i},x'{'_{i + 1}}} \right) = \arg {\min _{\left( {{e_1},{e_2}} \right)}}\left\{ {\left| {{e_1} - {x_i}} \right| + \left| {{e_2} - {x_{i + 1}}} \right|\left| {{e_1} = x{'_i} + 4{k_1},{e_2} = x{'_{i+1}} + 2{k_2},\left| {{e_1} - {e_2}} \right| \ge T,0 \le {e_1},{e_2} \le 255,0 \le T \le 31,{k_1},{k_2} \in Z} \right.} \right\}$重新调整$\left( {x'{'_i},x'{'_{i + 1}}} \right)$，最后，我们得到$$LSB\left( {x'{'_i}} \right) = {m_i},\quad f\left( {x'{'_i},x'{'_{i + 1}}} \right) = {m_{i + 1}}$$其中$0 \le x'{'_i},x'{'_{i + 1}} \le 255$,$\left| {x'{'_i} - x'{'_{i + 1}}} \right| \ge T$。解的存在性证明请参见附录。
- 第四步：数据隐藏后，结果图像被分成不重叠的$Bz \times Bz$区域块，然后将区域块按照根据$key_1$生成的随机的角度旋转。这个过程与第一步非常相似，除了随机角度是相反的。接下来我们在没有用于隐藏数据的一个预先设置的区域嵌入两个参数$\left( {T,Bz} \right)$

注意我们的方法有两个参数。第一个是数据预处理时用于区域划分的区域块大小$Bz$，另一个是嵌入区域选择使用的阈值$T$。在这篇文章中，$Bz$是从集合$\left\{ {1,4,8,12} \right\}$中随机选出。$T$属于$\left\{ {0,1 \ldots ,31} \right\}$并由图像内容和密文$M$（请参加第二步）。总之，每个图像只需要7（$7 = {\log _2}\left( 4 \right) + {\log _2}\left( {32} \right)$）比特的辅助信息。

这里给出一个例子。假设我们处理嵌入单元$\left( {{x_i},{x_{i + 1}}} \right)=\left(62,81\right)$，$m_i=1$，$m_{i+1}=0$，$T=19$。易得$\left| {{x_{i + 1}} - {x_i}} \right| = 19 \ge T$和$$\begin{align}
LSB\left( {62} \right) & = 0 \ne {m_i},\\
LSB\left( {\left\lfloor {\frac{{\left( {62 - 1} \right)}}{2}} \right\rfloor  + 81} \right) & = 1 \ne {m_{i + 1}}
\end{align}$$因此，我们调用Case\#4得到$$\left( {x{'_i},x{'_{i + 1}}} \right) = \left( {{x_i} + 1,{x_{i + 1}}} \right) = \left( {63,81} \right)$$新的差变成$d' = \left| {81 - 63} \right| = 18 < T$，我们根据公式重新调整它们最后得到$k_1=0,k_2=1$,$$\begin{align}
x'{'_i} &= x{'_i} + 4{k_1} = 63 + 4 \times 0 = 63\\
x'{'_{i + 1}} &= x{'_{i + 1}} + 2{k_2} = 81 + 2 \times 1 = 83
\end{align}$$在这里，我们有$d'' = \left| {83 - 63} \right| = 20 \ge T$和$$LSB\left( {63} \right) = {m_i},\quad LSB\left( {\left\lfloor {\left( {\frac{{63}}{2}} \right)} \right\rfloor  + 83} \right) = {m_{i + 1}}$$

###数据提取\label{subsec::ex}
为了提取数据，我们先从伪装图片提取辅助信息，即区域分块大小$Bz$和阈值$T$。然后我们做的工作和数据嵌入的第一步完全相同。伪装图像被划分为$Bz \times Bz$的分块区域，分块根据秘钥$key_1$生成的随机角度旋转。结果图像重排为一个行向量$V'$，最后，我们通过把$V'$划分为不重叠的两个连续的像素得到嵌入单元。

我们根据由秘钥$key_2$生成的伪随机顺序遍历绝对差大于等于阈值$T$的嵌入单元，直至所有的隐藏比特都被完全提取。对于每个合格的嵌入单元，也就是满足$\left| {x{'_{i + 1}} - x{'_i}} \right| \ge T$的$\left( {x{'_i},x{'_{i + 1}}} \right)$，我们这样提取两个秘密比特$m_i,m_{i+1}$:$${m_i} = LSB\left( {x'{'_i}} \right),\quad {m_{i + 1}} = LSB\left( {\left\lfloor {\frac{{x{'_i}}}{2}} \right\rfloor  + x{'_{i + 1}}} \right)$$，例如，我们处理单元$\left( {x{'_i},x{'_{i + 1}}} \right)=\left(63,83\right)$，$T=19$，我们最终这样得到秘密比特$${m_i} = LSB\left( {63} \right) = 1,\qquad {m_{i + 1}} = LSB\left( {\left\lfloor {\frac{{63}}{2}} \right\rfloor  + 83} \right) = 0$$

## 实验结果和分析(#exp)
在本节，我们将展现一些实验结果以表明我们提出的方法相比于在第二节中现有相关方法的有效性。我们使用了三个图像数据集用于算法评估，UCID[@schaefer2003ucid]包含1338个未压缩的大小为$384\times512$或$512\times384$彩色图像，NJIT数据集包含3680个使用不同相机拍摄的未压缩的大小为$512\times 768$或$768\times 512$彩色图像，以及我们的数据集SYSU包含982个大小为$640 \times 489$TIFF彩色图像。总之，有6000个原始的未压缩的图片包含（但不限于）风景，人物，植物，动物和建筑。所有图像在我们的实验中都转换成了灰度图像。

###嵌入容量和图片质量分析
我们的隐写方法的一个属性就是可以通过调整阈值$T$根据图片内容先选择较锐利的边缘区域来隐藏数据。如图5所示，要嵌入的秘密比特越多，阈值$T$变得越小，也就是更多载体图像中更低渐变的嵌入单元被释放了（请参加数据嵌入第三步中$EU\left( T \right)$的定义）。当$T$为$0$时，载体中所有的嵌入单元都可用。在这种情况下，我们的方法达到最大的嵌入容量100\%（对于文中所有方法100\%意味着1bpp），所以，我们提出的方法的嵌入容量除了7个额外的比特以外与LSBM和LSBMR几乎相同。

从图5可知，当嵌入率低时，大多数秘密比特都隐藏在边缘区域，比如，例子中低于30\%，这时这些光滑区比如左上角的天空保持不变。因此，我们的伪装的主观质量得到了基于人类视觉系统（HVS）特性的提升。

表1显示了嵌入率不同的七种隐写方法在6000张图像上的平均PSNR，加权PSNR(wPSNR是一种Checkman版本1.2[@pereira2001second]采用的更好的图像视觉度量，它考虑了HVS特征并用$$wPSNR = 10{\log _{10}}\frac{{\max {{\left( x \right)}^2}}}{{{{\left\| {NVF\left( {x' - x} \right)} \right\|}^2}}}$$优化传统的PSNR,其中$x$是载体图像，$x'$是伪装图像，$NVF$为噪声可见函数[@voloshynovskiy1999stochastic]）和平均修改率。\_

对于平均PSNR，可以看到LSBMR的表现最佳因为它使用了$\pm 1$嵌入机制，而且它的修改率低于除了AE-LES方法以外的其他方法。请注意PSNR的值独立于被修改像素的位置，因此我们的方法评价PSNR将略微低于LSBMR因为我们的方法需要重新调整一些嵌入单元保证正确的数据提取（更多细节见附录）。

对于评价wPSNR，HBC和我们的方法的表现非常相似并且通常优于其他方法，原因是使用这两种方法隐藏数据后，修改的像素总是位于载体上更锐利的边缘区域而光滑区保持不变（见图1），根据[@pereira2001second]的HVF，锐利的边缘地区的改变的权重小于光滑区，这意味着wPSNR的值应该大于那些用随机嵌入机制伪装的图像。

对于平均修改率，AE-LSB方法总是最低的。原因是根据AE-LSB嵌入的步骤，每个单个的像素的负载容量在所有方法中是最大的，也就是说对于相同的嵌入容易需要修改的像素更少。注意LSBM和HBC的平均修改率相同，都等于嵌入率的一半，或者LSBMR修改率的$4/3$。

综上所述，包括PSNR和wPSNR的我们的伪装的客观之类几乎是七种方法中最好的（对比下划线和括号里的数据）

## 视觉攻击
尽管我们的方法通过改变那些边缘区域上的像素来嵌入密文比特，但是在我们的扩展试验中不会在伪装图像的LSB平面留下明显的人工痕迹。图6是载体图片的LSB平面和应用我们的机制嵌入率为30\%和50\%的伪装图片的LSB平面，可见没有图5中的可见痕迹，大部分光滑区域如左上角的天空也很好的保持了原样，然而对于LSBM，LSBMR和一些随机嵌入机制的基于PVD的方法，光滑区不可避免地被污染从而变得更加随机。图7是载体的LSB平面和相同嵌入率50\%下分别使用七种隐写方法的伪装图像的LSB平面，可知使用LSBM，LSBNR，PVD和IPVD方法（尤其是有着高修改率的LSBM）的伪装图像的LSB平面比起其他方法的看上去更随机。如图3所示，放大后更容易观察到人工痕迹。注意HBC也能保留光滑区，而AE-LSB由于表1所示的低修改率，污染的光滑区更少。

## 统计攻击
RS分析：RS隐写分析[@fridrich2001reliable]是一种著名的探测LSB替代的隐写图像并估算隐藏信息大小的方法。在这个测试中，我们用这种隐写分析对我们的方法和HBC方法进行安全性评估。

因为HBC被视为LSB替换的特例（边缘自适应），LSB替换引入的结构性对称痕迹可以在相应的RS图中反应出来。如图8所示，${R_M}\left( {{S_M}} \right)$和${R_{ - M}}\left( {{S_{ - M}}} \right)$的差随着嵌入率的增大而增大。然而我们的机制实际上是基于LSBM的，可以避免这些基于LSB替换式的对称，因此RS隐写方法对于我们的方法伪装的图像失效。如图8所示，即使当嵌入率上升到100\%，${R_M}\left( {{S_M}} \right)$和${R_{ - M}}\left( {{S_{ - M}}} \right)$的差依然保持接近。

为了进行我们的方法和HBC方法的进一步安全性测试，我们使用4-D的RS特征，即用$R_M$，$S_M$，$R_{-M}$，$S_{-M}$来区分自然载体图像和它们的副本。对于每个嵌入率，原样本（包括载体和它们的副本）首先随机分为十个不重叠的子样本，然后保留一个子样本作为测试数据，剩下的九个用作训练集。在试验中使用了一个Fisher线性判别式。表2是超过10次替代选择测试集和训练集得到的平均探测结果。显然RS隐写分析对于HBC方法即使在低嵌入率如10\%时也非常有效，但是对于我们的伪装却失效了（对于所有嵌入率都接近50%的随机猜测）。

两个具体特征集：根据第3节A，我们提出的机制可以被归为一种基于LSBM的边缘自适应机制。因此，我们使用针对于LSBM的两个具体特征集来评价我们的方法和其他两个基于LSB的隐写方法，即LSBM和LSBMR。

- Li-1D[@li2008detecting]。计算基于刻度的探测器（例如标定HCF COM）作为图像中邻接像素之间的差值。在[@li2008detecting]中的实验结果现实这个方法优越于[@ker2005steganalysis]提出的之前的标定HCF COM方法。
- Huang-1D[@huang2007attack]。计算邻接灰阶数的改变率。与基于HCF COM的方法[@ker2005steganalysis]，[@li2008detecting]不同，它探测那些重叠的$3 \times 3$像素平衡分块的前两位平面在重嵌入操作后的统计改变。

接收者操作特征（ROC）曲线如图9所示，我们可以清楚看到这两种隐写算法即使在嵌入率高达75\%时探测我们的方法也都失效了（仍然更接近随机猜测），却在探测使用LSBM和LSMR方法的伪装时得到了满意的结果。

请注意对于一个给定的误判率（FPR），LSBMR的检测正确率略低于LSBM。其中的一个原因可能是两种方法都在嵌入机制中运用了$\pm 1$。然而，如表1所示，LSBMR的修改率略在相同嵌入率的前提略低于LSBM。接下来的测试中可以看到类似的探测结果。

四个通用特征集：在这个子节中，我们使用四个通用特征集来进一步评估我们的隐写机制和六个其他相关机制的安全性，包括两个典型的基于LSB的机制和四个基于边缘的机制。

- Shi-78D [@shi2005image]。用错误预测图像，测试图像，和他们的小波子带特征函数的统计矩来体现载体图像和伪装图像相关直方图间的差异属性。（78维）
- Farid-72D [@farid2002detecting]。由多尺度分解得到的高次统计矩，包含基于最优线性预测器的基系数和统计数据，用于采集载体图片的自然属性（72维）
- Moulin-156D [@wang2007optimized]。 从经验概率密度函数（pdfs）矩和正则化绝对CF中提取的特征。在我们的实验中，我们依照[@unser1986local]提出的提取机制，但省略特征选择过程。最高的统计次数设置为$N=6$，所以我们得到了156维的特征。
- Li-110D [@li2008textural]。从图像的局部线性转换系数[@unser1986local]的正则化直方图提取隐写特征。[@wang2007optimized]中的实验结果是这些特征可以采集嵌入数据前后局部纹理的特定变化，所以可以探测出隐藏数据的存在，尤其的一些自适应隐写算法的，比如MBNS[@zhang2005steganography]，MPB[@nguyen2006multi],和JPEG2000 BPCS[@noda2002bit]，对于低如10\%的嵌入率依然有效。

在实验中，我们先以10\%为步长设定10\%到50\%间不同的嵌入率使用七种隐写方法创造伪装图像，然后提取载体和伪装图像中上述的这些图像特征，分类中还用到了FLD分类器。表3是第4节C1所做的十轮交叉检验的平均探测准确率。从表3可知，在几乎所有的情况下我们的方法都优于其他六种方法，尤其是嵌入率低如30\%的时候。（110维）

例如，嵌入率为20\%时，我们的最大准确率59.29\%，这是在包括LSBM和LSBMR在内的典型的基于LSB方法的基础上提升了20\%。当嵌入率增大，比如达到50\%，我们的结果将会与LSBMR方法的表现更为接近，原因是载体图片中没有足够多的更锐利的边缘区域来隐藏如此大的密文，这种方法必须降低阈值$T$释放更多平滑/平坦区。例如，图5中绝对差大于等于2的嵌入单元用来隐藏数据，致使我们的扩展实验中表现出较弱的安全性。注意不同于数字水印和指纹隐藏技术，隐写者有自由去选择载体图片和/或隐写术来传递信息[@kharrazi2006cover]。在实践中，我们选择那些有良好隐藏特性的载体图像，也就是在我们的机制中载体图像拥有更多的边缘区域。因此，对于一个给定的密文，阈值$T$可以作为选择载体图片的盲准则。通常$T$越大，选中的载体包含的锐利的边缘区域越多，从而能获得更高的安全性。

基于实验，我们观察到前三个基于边缘的机制，即PVD，IPVD和AE-LSB都弱于基于LSB的方法。对于HBC方法，它的表现和我们的方法相似，尽管容易被RS分析探测出来（请参加表2），也意味着使用四种通用特征集很难探测出那些边缘区域的像素变化。

## 总结
在这篇文章中，我们研究了一种空间域中的边缘自适应隐写机制。如第2节所指出，自然图像中通常存在一些平滑区，导致载体图片的LSB不完全随机甚至像高位平面一样包含一些纹理信息。如果再这些区域植入消息，伪装图片的LSB会变得更加随机，根据我们的分析和扩展实验，这样很容易被探测出来。然而在大多数以前的隐写机制中，像素/像素对的选择主要依赖于PRNG而没有考虑内容区域的特性和要嵌入的密文大小的关系，致使光滑区在即使用很多有良好隐藏特性的可用的边缘区域的情况下仍然被这样一种随机选择机制污染。为了保留载体图像的统计和视觉特征，我们提出了一种可以自适应地根据由密文大小和内容边梯度决定的阈值，先将密文嵌入较为锐利的边缘区域的新机制。在数以千计的自然图像上使用不同的隐写算法评估的实验结果表明我们的伪装图片再视觉质量和安全性上相比典型的基于LSB的方法和它的边缘自适应版本都有显著的提高。

不仅如此，我们的自适应的思想也有望扩展到其他的隐写方法，比如嵌入率低于最大值的空间域或频域的音频/视频隐写。

## 附录
在附录中，我们将证明对于载体图像中的每个嵌入单元$\left( {{x_i},{x_{i + 1}}} \right)$，其中$d = \left| {{x_i} - {x_{i + 1}}} \right| \ge T$，我们提出的算法能在$LSB\left( {x'{'_i}} \right) = {m_i},f\left( {x'{'_i},x'{'_{i + 1}}} \right) = {m_{i + 1}}$且$0 \le x'{'_i},x'{'_{i + 1}} \le 255$，$\left| {x'{'_i} - x'{'_{i + 1}}} \right| \ge T$的条件下，根据公式以最小变形将它修改为一个新的像素对$\left( {x'{'_i},x'{'_{i + 1}}} \right)$。这对于保证我们可以区分那些用相同的阈值$T$嵌入数据前后的相同的选定区域是非常重要的。

证明：首先，我们给出二进制函数$f\left( {a,b} \right) = LSB\left( {\left\lfloor {a/2} \right\rfloor  + b} \right)$如下的一些性质：
$$f\left( {a,b} \right) \ne f\left( {a,b \pm 1} \right),f\left( {a - 1,b} \right) \ne f\left( {a + 1,b} \right),\forall a,b \in Z$$
然后我们有$$
\begin{align}
f\left( {a,b} \right) &= f\left( {a,b + 2{k_2}} \right) \\
f\left( {a,b} \right) &= f\left( {a + 4{k_1},b} \right),\forall b,{k_1},{k_2} \in Z
\end{align}
$$
我们按照第三节A第三步用如下公式表示四种情况：$$x{'_i} = {x_i} + {r_1},x{'_{i + 1}} = {x_{i + 1}} + {r_2}$$其中${r_1},{r_2} \in \left\{ {0, - 1, + 1} \right\},\left| {{r_1}} \right| + \left| {{r_2}} \right| \le 1$
基于嵌入过程和公式1，容易验证修改后的像素对$\left( {x'{'_i},x'{'_{i + 1}}} \right)$满足$$LSB\left( {x{'_i}} \right) = {m_i},f\left( {x{'_i},x{'_{i + 1}}} \right) = {m_{i + 1}}$$
如果$\left( {x'{'_i},x'{'_{i + 1}}} \right)$超出了$\left[ {0,255} \right]$的范围，或者新的差值$d' = \left| {x{'_i} - x{'_{i + 1}}} \right| \le T$，那么接下来就要按照如下方法重新调整它们。为了保留性质3，我们基于公式2限制$$x'{'_i} = x{'_i} + 4{k_1},x'{'_{i + 1}} = x{'_{i + 1}} + 2{k_2},\forall {k_1},{k_2} \in Z$$我们有$LSB\left( {x{'_i}} \right) = {m_i},f\left( {x{'_i},x{'_{i + 1}}} \right) = {m_{i + 1}}$，接下来，我们将说明对于约束$$0 \le x'{'_i},x'{'_{i + 1}} \le 255, \left| {x'{'_i} - x'{'_{i + 1}}} \right| \ge T$$存在这样的${k_1},{k_2} \in Z$。

不失一般性地假设$0 \le {x_i} \le {x_{i + 1}} \le 255$，则需要以如下两种情形重新调整$\left( {x'={'_i},x{'_{i + 1}}} \right)$。

Case#1。$x'_i$或$x'_{i+1}$超出了$\left[ {0,255} \right]$的范围，那么只有以下两种情形之一发生

- Case#1.1 ${x_i} = 0,{r_1} = 0,{r_2} = 0$$$\left( {x{'_i} = {x_i} - 1 = 0 - 1 =  - 1,x'{'_{i + 1}} = {x_{i + 1}}} \right)$$那么有$d' = \left| x{'_i} - x{'_{i + 1}} \right| = {x_{i + 1}} - \left( {{x_i} - 1} \right) = d + 1 \ge T + 1$
  - 如果$d \le 34$，那么$x{'_{i + 1}} = 0 + d \le 34$，我们令$x'{'_i} = x{'_i} + 4 =  - 1 + 4 = 3,x'{'_{i + 1}} = x{'_{i + 1}} + 4 \le 38$（$k_1=1,k_2=2$），那么得到$d''=d'=d+1 \ge T$
  - 如果$d > 34$，那么$x{'_{i + 1}} = 0 + d > 34$，我们令$x'{'_i} = x{'_i} + 4 =  - 1 + 4 = 3,x'{'_{i + 1}} = x{'_{i + 1}}$（$k_1=1,k_2=0$），那么得到$d''=d'=d+1 \ge T$，然后$d'' = \left| {x'{'_i} - x'{'_{i + 1}}} \right| = {x_{i + 1}} - \left( {{x_i} - 1 + 4} \right) = d - 3 > 31 = \max \left( T \right) \ge T$
- Case#1.2 $x_{i+1} = 255,{r_1} = 0,{r_2} = +1$$$\left( {x{'_i} = {x_i} ,x'{'_{i + 1}} = {x_{i + 1}}}+1=255+1=256 \right)$$，分析与Case#1.1相似。

Case#2 $d=T,d' = \left| {x{'_i} - x{'_{i + 1}}} \right|=d-1=T-1<T$，这时，$x{'_i}$和$x{'_{i + 1}}$一定都在$\left[ {0,255} \right]$的范围内，我们令$${R_l} = \left[ {0,x{'_i}} \right),{R_r} = \left( {{x_{i + 1}},255} \right]$$由于$\left| {{R_l}} \right| + d + \left| {{R_r}} \right| = 256$，则$d = 256 - \left| {{R_l}} \right| - \left| {{R_r}} \right| = T \le \max \left( T \right) = 31$，然后我们有$\left| {{R_l}} \right| + \left| {{R_r}} \right| \ge 256 - 31 = 225$，因此，必然存在一个区间$R_l$或$R_r$满足$\left| {{R_l}} \right|\ge 4$或$\left| {{R_r}} \right| \ge 2$，否则$\left| {{R_l}} \right| + d + \left| {{R_r}} \right| < 4+2=6$，存在矛盾。

- 如果$\left| {{R_r}} \right| \ge 2$，那么我们令$x'{'_i} = x{'_i},x'{'_{i + 1}} = x{'_{i + 1}} + 2 \le 255\left( {{k_1} = 0,{k_2} = 1} \right)$，得到$d'' = d' + 2 = T - 1 + 2 = T + 1 \ge T$
- 如果$\left| {{R_l}} \right|\ge 4$且$\left| {{R_r}} \right| < 2$那么我们令$x'{'_i} = x{'_i}-4\ge 0,x'{'_{i + 1}} = x{'_{i + 1}}\left( {{k_1} = -1,{k_2} = 0} \right)$，得到$d'' = d' + 4 = T - 1 +4 = T + 3 \ge T$
